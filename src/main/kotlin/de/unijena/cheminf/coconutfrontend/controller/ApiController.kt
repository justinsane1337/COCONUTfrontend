package de.unijena.cheminf.coconutfrontend.controller

import de.unijena.cheminf.npopensourcecollector.mongocollections.UniqueNaturalProduct
import de.unijena.cheminf.npopensourcecollector.mongocollections.UniqueNaturalProductRepository
import org.openscience.cdk.exception.CDKException
import org.openscience.cdk.exception.InvalidSmilesException
import org.openscience.cdk.interfaces.IAtomContainer
import org.openscience.cdk.silent.SilentChemObjectBuilder
import org.openscience.cdk.smiles.SmiFlavor
import org.openscience.cdk.smiles.SmilesGenerator
import org.openscience.cdk.smiles.SmilesParser
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController
import java.net.URLDecoder

@RestController
@RequestMapping("/api")
class ApiController(val uniqueNaturalProductRepository: UniqueNaturalProductRepository) {
    /*
    * custom api code goes here
    *
    * basic REST-API generated by Spring
    * see @RepositoryRestResource annotation in repository class(es)
    *
    */

    val smilesParser: SmilesParser = SmilesParser(SilentChemObjectBuilder.getInstance())
    val smilesGenerator: SmilesGenerator = SmilesGenerator(SmiFlavor.Unique)

    @RequestMapping("/search/structure")
    fun structureSearchBySmiles(@RequestParam("smiles") encodedSmiles: String): List<UniqueNaturalProduct> {
        val smiles = URLDecoder.decode(encodedSmiles, "UTF-8")

        return this.doStructureSearchBySmiles(smiles)
    }

    @RequestMapping("/search/simple")
    fun simpleSearch(@RequestParam("query") encodedQueryString: String): List<UniqueNaturalProduct> {
        val queryString = URLDecoder.decode(encodedQueryString, "UTF-8")
        println("Input queryString: $encodedQueryString")
        println("Decoded queryString: $queryString")
        return this.doSimpleSearch(queryString)
    }

    fun doStructureSearchBySmiles(smiles: String): List<UniqueNaturalProduct> {
        try {
            val parsedSmiles: IAtomContainer = this.smilesParser.parseSmiles(smiles)
            val canonicalSmiles: String = this.smilesGenerator.create(parsedSmiles)

            println("Input Smiles: $smiles")
            println("Canonical Smiles: $canonicalSmiles")

            return this.uniqueNaturalProductRepository.findByCleanSmiles(smiles)

        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }
    }

    fun doSimpleSearch(query: String): List<UniqueNaturalProduct> {
        // determine type of input on very basic principles without validation
        val regexMap: Map<String, Regex> = mapOf(
                "inchi" to Regex("^InChI=.*$"),
                "inchikey" to Regex("^[A-Z]{14}-[A-Z]{10}-[A-Z]$"),
                "smiles" to Regex("^[^Jj][A-Za-z0-9\\(\\)\\[\\]\\-=#$:\\+\\@\\.\\/\\>\\<]{3,}$")
        )

        val hitsMap = mutableMapOf<String, Boolean>()

        for ((name, regex) in regexMap) {
            hitsMap[name] = regex.containsMatchIn(query)
        }

        val naturalProducts: List<UniqueNaturalProduct>
        // only search by smiles if no other formats match
        when {
            hitsMap["inchi"]!! -> naturalProducts = this.uniqueNaturalProductRepository.findByInchi(query)
            hitsMap["inchikey"]!! -> naturalProducts = this.uniqueNaturalProductRepository.findByInchikey(query)
            hitsMap["smiles"]!! -> naturalProducts = this.doStructureSearchBySmiles(query)
            else -> naturalProducts = emptyList()
        }

        return naturalProducts
    }
}