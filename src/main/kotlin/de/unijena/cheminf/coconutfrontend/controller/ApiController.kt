package de.unijena.cheminf.coconutfrontend.controller

import de.unijena.cheminf.npopensourcecollector.mongocollections.UniqueNaturalProduct
import de.unijena.cheminf.npopensourcecollector.mongocollections.UniqueNaturalProductRepository
import org.openscience.cdk.exception.CDKException
import org.openscience.cdk.exception.InvalidSmilesException
import org.openscience.cdk.interfaces.IAtomContainer
import org.openscience.cdk.silent.SilentChemObjectBuilder
import org.openscience.cdk.smiles.SmiFlavor
import org.openscience.cdk.smiles.SmilesGenerator
import org.openscience.cdk.smiles.SmilesParser
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api")
class ApiController(val uniqueNaturalProductRepository: UniqueNaturalProductRepository) {
    /*
    * custom api code goes here
    *
    * basic REST-API generated by Spring
    * see @RepositoryRestResource annotation in repository class(es)
    *
    */

    val smilesParser: SmilesParser = SmilesParser(SilentChemObjectBuilder.getInstance())
    val smilesGenerator: SmilesGenerator = SmilesGenerator(SmiFlavor.Unique)

    @RequestMapping("/search/structure")
    fun structureSearchBySmiles(@RequestParam("smiles") smiles: String): List<UniqueNaturalProduct> {
        return this.doStructureSearchBySmiles(smiles)
    }

    @RequestMapping("/search/simple")
    fun simpleSearch(@RequestParam("query") queryString: String): Map<String, Any> {
        return this.doSimpleSearch(queryString)
    }

    fun doStructureSearchBySmiles(smiles: String): List<UniqueNaturalProduct> {
        try {
            val parsedSmiles: IAtomContainer = this.smilesParser.parseSmiles(smiles)
            val canonicalSmiles: String = this.smilesGenerator.create(parsedSmiles)

            return this.uniqueNaturalProductRepository.findByCleanSmiles(canonicalSmiles)

        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }
    }

    fun doSimpleSearch(query: String): Map<String, Any> {
        // determine type of input on very basic principles without validation
        val regexMap: Map<String, Regex> = mapOf(
                "inchi" to Regex("^InChI=.*$"),
                "inchikey" to Regex("^[A-Z]{14}-[A-Z]{10}-[A-Z]$"),
                "molecular_formula" to Regex("C[0-9]+?H[0-9].+"),
                "smiles" to Regex("^[^Jj][A-Za-z0-9\\(\\)\\[\\]\\-=#$:\\+\\@\\.\\/\\>\\<]{3,}$")
                // "molecular_weight" to Regex("^\\d+?[.,]?\\d+?$")
        )

        val hitsMap = mutableMapOf<String, Boolean>()

        for ((name, regex) in regexMap) {
            hitsMap[name] = regex.containsMatchIn(query)
        }

        // only search by smiles if no other formats match; problem: smiles matches almost everything
        val naturalProducts: List<UniqueNaturalProduct> = when {
            hitsMap["inchi"]!! -> this.uniqueNaturalProductRepository.findByInchi(query)
            hitsMap["inchikey"]!! -> this.uniqueNaturalProductRepository.findByInchikey(query)
            hitsMap["molecular_formula"]!! -> this.uniqueNaturalProductRepository.findByMolecularFormula(query)
            hitsMap["smiles"]!! -> this.doStructureSearchBySmiles(query)
            else -> emptyList()
        }

        val determinedInputType: String = when {
            hitsMap["inchi"]!! -> "InChI"
            hitsMap["inchikey"]!! -> "InChIKey"
            hitsMap["molecular_formula"]!! -> "molecular formula"
            hitsMap["smiles"]!! -> "SMILES"
            else -> ""
        }

        return mapOf(
            "originalQuery" to query,
            "determinedInputType" to determinedInputType,
            "naturalProducts" to naturalProducts
        )
    }
}